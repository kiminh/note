# 动态规划

- [基本描述](#基本描述)
- [基本思想](#基本思想)
- [基本概念](#基本概念)
  - [多阶段决策问题](#多阶段决策问题)
  - [动态规划问题中的术语](#动态规划问题中的术语)
- [基本结构](#基本结构)
- [基本模型](#基本模型)
- [适用条件](#适用条件)

## 基本描述

动态规划是运筹学的一个分支, 是求解决策过程的最优化的数学方法。 基本思想是吧多阶段过程转化为一系列单阶段问题, 利用各阶段之间的关系, 逐个求解。

动态规划一般可以分为线性规划, 区域动规, 树形动规, 背包动规。

应用实例: 最短路径问题, 项目管理, 网络优化等。

## 基本思想

动态规划算法通常用于求解具有某种最优性质的问题。 在这类问题中, 可能有许多可行解。 每个节对应一个值, 希望找到具有最优值的解。 动态规划与分治法类似, 器基本思想是将带球节问题分解为若干个子问题, 先求解子问题, 再从这些子问题的解得到原问题的解。 与分治法不同的是, 适用于动态规划求解的问题, 经分解得到的子问题往往不是相互独立的。

## 基本概念

### 多阶段决策问题

如果一类活动过程可以分为若干相互联系的阶段, 在每一个阶段都需要做出决策, 一个阶段的决策确定后, 常常影响到下一个阶段的决策, 从而完全确定了一个过程的活动路线, 则称之为多阶段决策问题。

各个阶段的决策构成一个决策序列, 称为一个策略。 每一个阶段都有若干个决策可供选择, 因而有许多策略可供选取, 对英语一个策略可以确定的活动的效果, 这个效果可以用数量来确定。 策略不同, 效果也不同, 多阶段策略问题, 就是要在可以选择的那些策略中间选取一个最优策略, 使得在预定的标准下达到最好的效果。

### 动态规划问题中的术语

- 阶段

> 吧所有求解问题的过程恰当地分成若干个相互联系的阶段, 一边求解, 过程不同, 阶段数就可能不同。 描述阶段的变量称为阶段变量。 多数情况下, 阶段变量是离散的, 用 k 表示。 此外, 也有阶段变量是连续的情形。 如果过程可以在任何时刻错处决策, 且再任意两个不同的时刻之间允许有无穷多个决策时, 阶段变量就是连续的。

- 状态

> 状态表示每个阶段开始面临的自然状况或客观条件, 它不以主观意志转移, 称为不可控因素。  
> 过程的状态通常可以用一个或一组数来描述, 称为状态变量。 一般, 状态时离散的, 蛋优势为了方便也可以将状态去成连续的。 此外, 状态可以有多个分量(多维情形), 因而用向量来表示。 而在每个阶段的状态维数可以不同。当过程按所有可能不同的发展方式发展时, 过程各段的状态变量将在某一确定的范围内取值。 状态变量取值的集合称为状态集合。

- 无后效性

> 如果给定某一阶段的状态, 则再这一阶段以后过程的发展不受这阶段以前的各状态的影响, 所有各阶段都确定时, 整个过程也就确定了。即: 过程的历史只能通过当前的状态去影响它的未来发展, 这个性质称为无后效性。

- 决策

> 一个阶段的状态给定后, 从改状态演变到下一阶段的一种选择称为决策。不同的决策对应着不同的数值, 描述决策的变量称为决策变量, 因状态满足无后效性, 故再每个阶段决策时, 只需要考虑当前的状态而无需考虑过程的历史。  

## 基本结构

多阶段决策问题中, 各个阶段采取的决策, 一般来说与时间有关, 决策依赖于当前状态, 又随即引起状态的转移, 一个决策序列就是在变化的状态中产生出来的。

## 基本模型

根据上例分析和动态规划的基本概念, 动态规划有以下基本模型:

1. 确定问题的决策对象。
2. 对决策过程划分阶段。
3. 对各阶段确定状态变量。
4. 根据状态变量确定费用函数和目标函数。
5. 换库各阶段状态变量的转移过程, 确定状态转移方程。

## 适用条件

适用动态规划的问题必须满足**最优化原理**和**无后效性**。

1. 最优化原理(最优子结构性质): 一个最优化策略具有这样的性质, 不论过去状态和决策如何, 对前面的决策所形成的状态而言, 余下的诸决策必须构成最优策略。 简而言之, 一个最优化策略的子策略总是最优的。 一个问题满足最优化原理又称其具有最优子结构性质。
2. 无后效性: 将各阶段按照一定的次序排列好之后, 对于某个给定的阶段状态, 它以前各阶段的状态无法直接影响它未来的决策, 而只能通过当前的这个状态。 换句话说, 每个状态都是过去历史的一个完整总结。 这就是无后向性, 又称为无后效性。
3. 子问题的重叠性: 动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。 其中的关键在于解决冗余, 这是动态规划算法的根本目的。 动态规划实质上是一种以空间换时间的技术, 它在实现的过程中, 不得不存储产生过程中的各种状态, 所以它的空间复杂度要大于其它的算法。
