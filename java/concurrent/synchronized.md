# Synchronized 相关

- [应用方式](#应用方式)
  - [修饰实例方法](#修饰实例方法)
  - [修饰静态方法](#修饰静态方法)
  - [修饰代码块](#修饰代码块)
- [底层语意原理](#底层语意原理)
- [JVM 对 synchronized 的优化](#jvm-对-synchronized-的优化)
  - [偏向锁](#偏向锁)
  - [轻量级锁](#轻量级锁)
  - [重量级锁](#重量级锁)
  - [自旋锁](#自旋锁)
  - [锁消除](#锁消除)
- [关键点](#关键点)
  - [synchronized 的可重入性](#synchronized-的可重入性)
  - [线程中断和 synchronized](#线程中断和-synchronized)
    - [线程中断](#线程中断)
    - [中断与 synchronized](#中断与-synchronized)
  - [等待唤醒机制与 synchronized](#等待唤醒机制与-synchronized)

## 应用方式

- 修饰实例方法: 作用域当前实例枷锁, 进入同步代码前要获得当前实例的锁。
- 修饰静态方法: 作用域当前类对象加锁, 进入同步代码前要获得当前类对象的锁。
- 修饰代码块: 指定枷锁对象, 对给定对象加锁, 进入同步代码库前要获得给定对象的锁。

### 修饰实例方法

用 `synchronized` 修饰实例对象中的实例方法.

### 修饰静态方法

### 修饰代码块

## 底层语意原理

## JVM 对 synchronized 的优化

锁的状态总共有四种: 无锁状态, 偏向锁, 轻量级锁, 重量级锁。 随着锁的竞争, 锁可以从偏向锁升级到轻量级锁, 再升级到重量级锁。 锁的升级是单向的, 只能从低到高升级, 不会出现锁的降级。

### 偏向锁

偏向锁是 Java 6 引入的新锁, 针对加锁操作的优化手段, 大多数情况下, 锁不仅存在多线程竞争, 还存在同一线程多次获得, 为减少同一线程获取锁的代价, 引入了偏向锁。 其核心思想是: 如果一个线程获得了锁, 那么锁进入偏向模式, 此时 Mark Word 的结构也变成偏向锁的结果。 当这个线程再次请求锁时, 无需做任何同步操作, 省去了大量锁申请的操作。 对于锁竞争激烈的场合, 偏向锁就失效了, 因为极有可能每次申请锁的线程都不是相同的。 偏向锁失效时, 先升级为轻量级锁。

### 轻量级锁

偏量锁升级为轻量级锁后, Mark Word 的结构也变为轻量级锁的结构。 轻量级锁的依据是: **绝大部分的锁在整个同步周期内都不存在竞争**, 这个依据是经验数据。 轻量级锁适应的场景是线程交替执行同步快的场合。 如果存在同一时间访问同一锁的场合, 就会导致轻量级锁升级为重量级锁。

### 重量级锁

### 自旋锁

轻量级锁失效后, 虚拟机为避免线程在操作系统层面挂起, 会进行一项称为自旋锁的优化手段。 这是基于大多数情况下, 线程持有锁的时间都不会太长, 如果直接挂起到操作系统层面的线程可能会得不偿失。 因为操作系统实现线程间的切换需要从用户态转换到核心态, 这个转换需要的时间较长, 事件成本高。

### 锁消除

消除锁是虚拟机另一种锁的优化。 虚拟机在编译时, 通过对运行上下文的扫描, 去除不可能存在共享资源竞争的锁, 通过这种方式消除没有必要的锁, 可以节省毫无意义的请求锁时间。

## 关键点

### synchronized 的可重入性

### 线程中断和 synchronized

#### 线程中断

#### 中断与 synchronized

### 等待唤醒机制与 synchronized
